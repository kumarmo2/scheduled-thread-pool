use parking_lot::{Condvar, Mutex};
use std::{
    cmp::Ordering,
    collections::BinaryHeap,
    sync::Arc,
    thread,
    time::{Duration, Instant},
};
struct Job {
    // TODO: Need to add functionality of cancel.
    work: Box<dyn Fn() + Send + 'static>,
    scheduled_runtime_instant: Instant,
}

impl Job {
    fn new(work: Box<dyn Fn() + Send + 'static>, instant: Instant) -> Self {
        Self {
            work,
            scheduled_runtime_instant: instant,
        }
    }
}

impl Eq for Job {}

impl PartialEq for Job {
    fn eq(&self, other: &Self) -> bool {
        self.scheduled_runtime_instant == other.scheduled_runtime_instant
    }
}

impl PartialOrd for Job {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Job {
    fn cmp(&self, other: &Self) -> Ordering {
        self.scheduled_runtime_instant
            .cmp(&other.scheduled_runtime_instant)
            .reverse()
    }
}

struct Worker {
    id: u8,
    shared_pool: Arc<SharedPool>,
}

impl Worker {
    fn new(shared_pool: Arc<SharedPool>, id: u8) -> Self {
        Self { id, shared_pool }
    }
}

impl Worker {
    fn start(self) {
        thread::spawn(move || {
            self.run();
        });
    }

    fn run(&self) {
        enum Wait {
            Indefinite,
            Timeout(Instant),
        }

        loop {
            let cvar = &self.shared_pool.cvar;
            let mut guard = self.shared_pool.inner.lock();
            let wait = match guard.queue.peek() {
                None => Wait::Indefinite,
                Some(job) => Wait::Timeout(job.scheduled_runtime_instant),
            };
            // TODO: Refactor
            match wait {
                Wait::Indefinite => {
                    cvar.wait(&mut guard);
                }
                Wait::Timeout(wait_time) => {
                    let timeout_result = cvar.wait_until(&mut guard, wait_time);
                    if timeout_result.timed_out() {
                        match guard.queue.peek() {
                            Some(job) => {
                                if job.scheduled_runtime_instant <= wait_time {
                                    if let Some(job) = guard.queue.pop() {
                                        // println!("executing the job from worker: {}", self.id);
                                        (job.work)()
                                    }
                                }
                            }
                            None => {}
                        }
                    }
                }
            }
        }
    }
}

struct InnerPool {
    queue: BinaryHeap<Job>,
    shutdown: bool,
}

struct SharedPool {
    cvar: Condvar,
    inner: Mutex<InnerPool>,
}

pub struct ScheduledSharedThreadPool {
    pool: Arc<SharedPool>,
}

impl ScheduledSharedThreadPool {
    pub fn new(size: u8) -> Self {
        let pool = Arc::new(SharedPool {
            cvar: Condvar::new(),
            inner: Mutex::new(InnerPool {
                queue: BinaryHeap::new(),
                shutdown: false,
            }),
        });
        for id in 0..size {
            let worker = Worker::new(pool.clone(), id);
            worker.start();
        }
        Self { pool: pool }
    }
}

impl ScheduledSharedThreadPool {
    // TODO: Make sure only one definition of execute should ever be generated by the compiler.
    pub fn execute<F: Fn() + Send + 'static>(&self, work: F) {
        let new_job = Job::new(Box::new(work), Instant::now());
        self.schedule(new_job);
    }

    fn schedule(&self, job: Job) {
        let mut inner = self.pool.inner.lock();
        let cvar = &self.pool.cvar;
        match inner.queue.peek() {
            Some(scheduled_job) => {
                if scheduled_job.scheduled_runtime_instant > job.scheduled_runtime_instant {
                    cvar.notify_all();
                }
            }
            None => {
                cvar.notify_all();
            }
        }
        inner.queue.push(job);
        cvar.notify_all();
    }

    // TODO: Make sure only one definition of execute_after should ever be generated by the compiler.
    pub fn execute_after<F: Fn() + Send + 'static>(&self, work: F, dur: Duration) {
        let scheduled_runtime_instant = Instant::now() + dur;
        let new_job = Job::new(Box::new(work), scheduled_runtime_instant);

        self.schedule(new_job);
    }
}

#[cfg(test)]
mod tests {
    use super::ScheduledSharedThreadPool;
    use std::{
        thread,
        time::{Duration, Instant},
    };

    #[test]
    fn it_works() {
        let thread_pool = ScheduledSharedThreadPool::new(2);
        let now = Instant::now();
        thread_pool.execute_after(
            move || println!("from 1 work, elapsed: {:?}", now.elapsed()),
            Duration::from_secs(5),
        );
        thread_pool.execute_after(
            move || println!("from 2 work, elapsed: {:?}", now.elapsed()),
            Duration::from_secs(7),
        );
        thread_pool.execute_after(
            move || println!("from 3 work, elapsed: {:?}", now.elapsed()),
            Duration::from_secs(4),
        );
        thread_pool.execute_after(
            move || println!("from 4 work, elapsed: {:?}", now.elapsed()),
            Duration::from_secs(2),
        );
        thread_pool.execute(move || println!("from 5 work, elapsed: {:?}", now.elapsed()));
        thread::sleep(Duration::from_secs(10));
    }
}
