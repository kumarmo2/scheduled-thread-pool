use parking_lot::{Condvar, Mutex};
use std::{
    cmp::Ordering,
    collections::BinaryHeap,
    sync::Arc,
    thread,
    time::{Duration, Instant},
};
struct Job {
    // TODO: Need to add functionality of cancel.
    work: Box<dyn Fn() + Send + 'static>,
    left_time: Instant,
    id: usize,
}

impl Job {
    fn new(id: usize, work: Box<dyn Fn() + Send + 'static>, left_time: Instant) -> Self {
        Self {
            work,
            left_time,
            id,
        }
    }
}

impl Eq for Job {}

impl PartialEq for Job {
    fn eq(&self, other: &Self) -> bool {
        self.left_time == other.left_time
    }
}

impl PartialOrd for Job {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Job {
    fn cmp(&self, other: &Self) -> Ordering {
        self.left_time.cmp(&other.left_time).reverse()
    }
}

struct Worker {
    id: u8,
    shared_pool: Arc<SharedPool>,
}

impl Worker {
    fn new(shared_pool: Arc<SharedPool>, id: u8) -> Self {
        Self { id, shared_pool }
    }
}

impl Worker {
    fn start(self) {
        thread::spawn(move || {
            self.run();
        });
    }

    fn run(&self) {
        enum Wait {
            Indefinite,
            Timeout(Instant),
        }

        loop {
            let cvar = &self.shared_pool.cvar;
            let mut guard = self.shared_pool.inner.lock();
            let wait = match guard.queue.peek() {
                None => Wait::Indefinite,
                Some(job) => Wait::Timeout(job.left_time),
            };
            match wait {
                Wait::Indefinite => {
                    cvar.wait(&mut guard);
                }
                Wait::Timeout(time) => {
                    let mut job = guard.queue.pop().unwrap();
                    // TODO: complete the implementation.
                    println!("job: {}, queued in worker: {}", job.id, self.id);
                    let wait_result = cvar.wait_until(&mut guard, time);
                    if wait_result.timed_out() {
                        println!("executing job: {} from worker: {}", job.id, self.id);
                        (job.work)()
                    } else {
                        println!("worker interrupted");
                        let dur: Duration = job.left_time - Instant::now();
                        let left_time: Instant = Instant::now() + dur;
                        job.left_time = left_time;
                        // println!("requeued in worker: {}", self.id);
                        guard.queue.push(job);
                    }
                }
            }
        }
    }
}

struct InnerPool {
    queue: BinaryHeap<Job>,
    shutdown: bool,
}

struct SharedPool {
    size: u8,
    cvar: Condvar,
    inner: Mutex<InnerPool>,
}

pub struct ScheduledSharedThreadPool {
    pool: Arc<SharedPool>,
}

impl ScheduledSharedThreadPool {
    pub fn new(size: u8) -> Self {
        let pool = Arc::new(SharedPool {
            size,
            cvar: Condvar::new(),
            inner: Mutex::new(InnerPool {
                queue: BinaryHeap::new(),
                shutdown: false,
            }),
        });
        for id in 0..size {
            let worker = Worker::new(pool.clone(), id);
            worker.start();
        }
        Self { pool: pool }
    }
}

impl ScheduledSharedThreadPool {
    // TODO: Make sure only one definition of execute should ever be generated by the compiler.
    pub fn execute<F: Fn() + Send + 'static>(&self, work: F) {
        todo!()
    }

    // TODO: Make sure only one definition of execute_after should ever be generated by the compiler.
    pub fn execute_after<F: Fn() + Send + 'static>(&self, work: F, dur: Duration) {
        println!("sdfsdfsdf");
        let cvar = &self.pool.cvar;
        let left_time = Instant::now() + dur;
        let mut lock = self.pool.inner.lock();
        let job = Job::new(lock.queue.len(), Box::new(work), left_time);

        lock.queue.push(job);
        println!("pushed===========");
        let thread_count = cvar.notify_all();
        println!(
            "============================woke up {} threads",
            thread_count
        );
    }
}

#[cfg(test)]
mod tests {
    use super::ScheduledSharedThreadPool;
    use std::{thread, time::Duration};

    #[test]
    fn it_works() {
        let thread_pool = ScheduledSharedThreadPool::new(10);
        for i in (0u64..100u64).rev() {
            thread_pool.execute_after(
                move || println!("from {} work", 100 - i),
                Duration::from_secs(i),
            );
        }
        thread::sleep(Duration::from_secs(105));
    }
}
